//Пакет incrementor предоставляет интерфейс Инкрементора - счетчика о нуля то максимального значения с шагом в единицу
package incrementor

import (
	"errors"
	"sync"
)

// Вычисляем максимальное значение типа int для данной архитектуры платформы
// ^uint(0) - максимальное значение uint побитово сдвигаем вправо для бита под знак
const MaximumInt = int(^uint(0) >> 1)

// Ошибка при установке отрицательно значения максимума
var ErrNegativeMaximumValue = errors.New("the maximum value of increment must be a non negative number")

// Incrementor является интерфейсом, что более удобно в использовании и соответствует принципу
// “accept interfaces, return structs”
type Incrementor interface {
	// GetNumber возвращает текущее число. В самом начале это ноль. Максимумом, который может вернуть данныя функция
	// является максимальное значение типа int в данной архитектуре или установленное с помощью метода
	// SetMaximumValue максимальное значение
	// Возвращаемым типом выбран int согласно ТЗ.
	GetNumber() int

	// IncrementNumber увеличивает текущее число на один. После каждого вызова этого метода getNumber() будет возвращать число
	// на один больше, но не больше максимального значения.
	IncrementNumber()

	// SetMaximumValue устанавливает максимальное значение текущего числа. Когда при вызове IncrementNumber() текущее число достигает
	// Этого значения, оно обнуляется, т.е. getNumber() начинает снова возвращать ноль, и снова один после следующего
	// Вызова IncrementNumber() и так далее. По умолчанию максимум -- максимальное значение int.
	// ВНИМАНИЕ! Максимальное значение типа int зависит от архитектуры платформы.
	// Если при смене максимального значения число начинает превышать максимальное значение, то число обнуляется.
	// Нельзя позволять установить тут число меньше нуля.
	SetMaximumValue(maximumValue int) error
}

// Объявляем неэкспортируемую структуру increment, которая реализует интерфейс Incrementor
type increment struct {
	number       int          // Значение
	maximumValue int          // Максимальное значение
	mutex        sync.RWMutex // Mutex для защиты переменных при работе с многопоточностью
}

// NewIncrementor - конструктор объекта increment с параметрами по умолчанию, реализующего интерфейс Incrementor.
func NewIncrementor() *increment {
	return &increment{
		number:       0,          // Значение по умолчанию равно нулю
		maximumValue: MaximumInt, // Максимум по умолчанию равен максимуму int в данной архитектуре платформы
	}
}

// Возвращает текущее число
func (inc *increment) GetNumber() int {
	// Используем mutex для блокировки доступа на запись к объекту из других вызовов, пока значение не будет возвращено
	inc.mutex.RLock()
	defer inc.mutex.RUnlock()
	return inc.number
}

// Увеличивает число на единицу
func (inc *increment) IncrementNumber() {
	// Используем mutex для блокировки доступа к объекту на запись и на чтение из других вызовов метода,
	// пока не будет установлено новое значение
	inc.mutex.Lock()
	defer inc.mutex.Unlock()
	// При достижении максимума обнуляем значение.
	// Здесь используется оператор сравнения ">=", а не "==", для того, чтобы при установке отрицательного
	// значения для максимума (например, через unsafe) инкрементатор всегда возвращал 0, а не уходил в бесконечность.
	if inc.number >= inc.maximumValue {
		inc.number = 0
		return
	}
	// Здесь используется обычное увеличение значения на еденицу. Атомарная операция (например, atomic.AddInt32)
	// здесь не применяется по той причине, что mutex все-равно необходим для защиты при проверке выше, а
	// тип значения int не имеет конкретной разрядности в коде.
	inc.number++
}

// Устанавливает максимальное число
func (inc *increment) SetMaximumValue(maximumValue int) error {
	// Проверяем, чтобы maximumValue было неотрицательным, иначе возвращаем ошибку.
	// Отсутствие проверки maximumValue > MaximumInt обусловлено тем, что сам компилятор не допустит
	// переполнения int и выдаст ошибку - overflows int
	if maximumValue < 0 {
		return ErrNegativeMaximumValue
	}
	// Используем mutex для блокировки доступа к объекту из других вызовов метода,
	// пока не будет установлено новое значение
	inc.mutex.Lock()
	defer inc.mutex.Unlock()
	// Устанавливаем указанное значение максимума
	inc.maximumValue = maximumValue
	// Если при смене максимального значения число начинает превышать данное  максимальное значение, то число обнуляется
	if inc.number > inc.maximumValue {
		inc.number = 0
	}
	// Возвращаем nil вместо ошибки
	return nil
}
